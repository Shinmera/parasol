#|
 This file is a part of Parasol
 (c) 2014 TymoonNET/NexT http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.tymoonnext.parasol)

(defvar *spline-adjust-buffer* 500)

(defun idata (var data-slot pos)
  (aref (aref var data-slot) pos))

(defgeneric (setf idata) (val var data-slot pos)
  (:method (val var data-slot pos)
    (setf (aref (aref var data-slot) pos) val)))

(defun copy-adjustable (array)
  (let ((new (make-array (length array) :element-type 'float :adjustable T :fill-pointer T)))
    (loop for i from 0 below (length array)
          do (setf (aref new i) (aref array i)))
    new))

(defun ensure-length (vector required-length)
  (cond ((< (array-dimension vector 0) required-length)
         (adjust-array vector (+ required-length *spline-adjust-buffer*)
                       :fill-pointer required-length))
        ((< (fill-pointer vector) required-length)
         (setf (fill-pointer vector) required-length)))
  vector)

(defclass spline (curve)
  ((%data :initarg :points :initform (make-array 3 :adjustable T :fill-pointer 0) :accessor data)
   (%spline-data :initform (make-array 3 :adjustable T :fill-pointer 0) :accessor spline-data)
   (%interpolated :initform (make-array 3 :adjustable T :fill-pointer 0) :accessor interpolated)
   (%distances :initform NIL :accessor distances)
   (%point-distance :initarg :point-distance :initform 0 :accessor point-distance)
   (%point-amount :initarg :point-amount :initform 0 :accessor point-amount)))

(defmethod print-object ((spline spline) stream)
  (print-unreadable-object (spline stream :type T :identity T)
    (format stream "(~d/~d)" (length (data spline)) (length (aref (data spline) 0))))
  spline)

(defgeneric (setf point-distance) (point-distance spline)
  (:method (point-distance (spline spline))
    (setf (slot-value spline '%point-distance)
          point-distance)
    (when (/= (length (distances spline)) 0)
      (setf (point-amount spline)
            (1+ (ceiling (/ (aref (distances spline) (1- (length (distances spline))))
                            point-distance)))))))

(defgeneric calculate-distances (spline &key from)
  (:method ((spline spline) &key (from 0))
    (let* ((data (data spline))
           (distances (distances spline))
           (len (length (aref data 0))))
      (when (< 1 len)
        (ensure-length distances len)
        (let ((err NIL)
              (x-left 0.0) (y-left 0.0)
              (x-right 0.0) (y-right 0.0)
              (x-middle 0.0) (y-middle 0.0)
              (g 0.0) (dn 0.0))
          (declare (float x-left y-left x-right y-right x-middle y-middle g dn))
          (flet ((calculate-distance (i)
                   (if (= dn 0.0)
                       (setf g 1.0)
                       (let ((dz (+ (* x-right x-middle)
                                    (* y-right y-middle))))
                         (if (= dz 0.0)
                             (setf g (/ PI 2))
                             (setf dz (/ dz dn)
                                   g (* (sqrt (1+ (expt dz 2)))
                                        (atan (/ 1 (abs dz))))))))
                   (let ((distance (* g (sqrt (+ (expt x-left 2)
                                                 (expt y-left 2))))))
                     (if (< distance 0.0)
                         (setf err T) ; somehow this happened.
                         (setf (aref distances i)
                               (+ (aref distances (1- i)) distance))))))
            ;; Calculate middle
            (loop for i from (1+ from) below (1- len)
                  do (setf x-left (- (idata data 0 i)
                                     (idata data 0 (1- i)))
                           y-left (- (idata data 1 i)
                                     (idata data 1 (1- i)))
                           x-right (- (idata data 0 (1+ i))
                                      (idata data 0 i))
                           y-right (- (idata data 1 (1+ i))
                                      (idata data 1 i))
                           x-middle (- (idata data 0 (1+ i))
                                       (idata data 0 (1- i)))
                           y-middle (- (idata data 1 (1+ i))
                                       (idata data 1 (1- i)))
                           dn (- (* x-left y-right)
                                 (* y-left x-right)))
                     (calculate-distance i)
                  until err)
            ;; Calculate end point
            (unless err
              (setf g x-left
                    x-left (- x-right)
                    x-right (- g)
                    g y-left
                    y-left (- y-right)
                    y-right (- g)
                    x-middle (- x-middle)
                    y-middle (- y-middle)
                    dn (- (* x-left y-right)
                          (* y-left x-right)))
              (calculate-distance (1- len))))
          ;; Something screwed up. Fix it with a linear approximation.
          (when err
            (loop for i from (1+ from) below len
                  do (let ((distance (sqrt (+ (expt (- (idata data 0 (- i 1))
                                                       (idata data 0 (- i 2))) 2)
                                              (expt (- (idata data 1 (- i 1))
                                                       (idata data 1 (- i 2))) 2)))))
                       (setf (aref distances i)
                             (+ (aref distances (1- i)) distance))))))))))

(defgeneric calculate-spline-data (spline &key from)
  (:method ((spline spline) &key (from 0))
    (let* ((data (data spline))
           (len (length (aref data 0)))
           (datacount (length data)))
      (when (< 1 len)
        (dotimes (j datacount)
          (let ((u (make-array len :element-type 'float :initial-element 0.0))
                (c (aref (spline-data spline) j))
                (distances (distances spline))
                (data (aref (data spline) j)))
            (ensure-length c len)
            (loop for i from (1+ from) below (1- len)
                  do (let* ((q (/ (- (aref distances i)
                                     (aref distances (1- i)))
                                  (- (aref distances (1+ i))
                                     (aref distances (1- i)))))
                            (p (+ 2 (* q (aref c i)))))
                       (setf (aref c i) (/ (1- q)
                                           p)
                             (aref u i) (/ (- (/ (* 6 (- (/ (- (aref data (1+ i))
                                                               (aref data i))
                                                            (- (aref distances (1+ i))
                                                               (aref distances i)))
                                                         (/ (- (aref data i)
                                                               (aref data (1- i)))
                                                            (- (aref distances i)
                                                               (aref distances (1- i))))))
                                                 (- (aref distances (1+ i))
                                                    (aref distances (1- i))))
                                              (* q (aref u (1- i))))
                                           p))))
            (setf (aref c (1- len)) 0.0)
            (loop for i downfrom (- len 2) to from
                  do (setf (aref c i)
                           (+ (* (aref c i)
                                 (aref c (1+ i)))
                              (aref u i))))))))))

(defun interpolate-spline (spline x c distance)
  (let ((distances (distances spline)))
    (if (< (length distances) 2)
        0.0
        (let ((klow 1)
              (khigh (length distances)))

          (loop while (< 1 (- khigh klow))
                do (let ((k (floor (/ (+ khigh klow) 2))))
                     (if (< distance (aref distances (1- k)))
                         (setf khigh k)
                         (setf klow k))))
          (decf khigh)
          (decf klow)
          (let ((dx (- (aref distances khigh)
                       (aref distances klow))))
            (if (= 0 dx)
                (/ (+ (aref x klow) (aref x khigh))
                   2)
                (let ((ai (/ (- (aref distances khigh) distance)
                             dx))
                      (bi (/ (- distance (aref distances klow))
                             dx)))
                  (+ (* ai (aref x klow))
                     (* bi (aref x khigh))
                     (/ (* (+ (* (- (expt ai 3) ai)
                                 (aref c klow))
                              (* (- (expt bi 3) bi)
                                 (aref c khigh)))
                           dx dx)
                        6)))))))))

(defgeneric calculate-interpolation (spline &key from)
  (:method ((spline spline) &key (from 0))
    (let ((len (length (aref (data spline) 0)))
          (point-amount (point-amount spline))
          (point-distance (point-distance spline)))
      (when (< 1 len)
        (loop for data across (data spline)
              for spline-data across (spline-data spline)
              for inter across (interpolated spline)
              do (ensure-length inter point-amount)
                 (loop for j from (* from (floor (/ point-amount len))) below point-amount
                       do 
                          (setf (aref inter j)
                                (interpolate-spline spline data spline-data (* j point-distance)))))))))

(defgeneric add-data-point (spline x y &rest additional-data)
  (:method ((spline spline) x y &rest additional-data)
    (let ((new-data (cons x (cons y additional-data)))
          (len (length (aref (data spline) 0))))
      (unless (= (length new-data) (length (data spline)))
        (error "Wrong amount of data points! Required: ~d" (length (data spline))))
      (when (or (= 0 len)
                (and (/= x (idata (data spline) 0 (1- len)))
                     (/= y (idata (data spline) 1 (1- len)))))
        (loop for data in new-data
              for i from 0
              do (vector-push-extend (float data) (elt (data spline) i)))
        
        ;; recalculate three last
        (let ((newpos (- (length (aref (data spline) 0)) 3)))
          (when (<= 0 newpos)
            (calculate-distances spline :from newpos)
            (setf (point-distance spline) (point-distance spline))
            (calculate-spline-data spline :from newpos)
            (calculate-interpolation spline :from newpos)))))
    spline))

(defun make-spline (x y &rest additional-data)
  (let ((spline (make-instance 'spline)))
    (let ((len (length x)))
      (loop for data in (cons x (cons y additional-data))
            do (when (/= len (length data))
                 (error "Not all arrays are the right size!"))
               (vector-push-extend (copy-adjustable data) (data spline))
               (vector-push-extend (make-array len :element-type 'float :initial-element 0.0 :adjustable T :fill-pointer T) (spline-data spline))
               (vector-push-extend (make-array len :element-type 'float :initial-element 0.0 :adjustable T :fill-pointer T) (interpolated spline)))
      (setf (distances spline)     (make-array len :element-type 'float :initial-element 0.0 :adjustable T :fill-pointer T)))
    (calculate-distances spline)
    (setf (point-distance spline) 2)
    (calculate-spline-data spline)
    (calculate-interpolation spline)
    spline))

(defun make-empty-spline (&optional (field-count 2))
  (when (< field-count 2)
    (error "FIELD-COUNT must be >=2."))
  (apply #'make-spline (loop repeat field-count collect #1A())))

(defmethod make-curve ((type (eql 'spline)))
  (make-empty-spline 5))

(defmethod record-point ((spline spline) x y x-tilt y-tilt pressure)
  (add-data-point spline x y x-tilt y-tilt pressure))

(defmethod point-count ((spline spline))
  (length (aref (interpolated spline) 0)))

(defmethod point-data ((spline spline) pos)
  (list (aref (aref (interpolated spline) 0) pos)
        (aref (aref (interpolated spline) 1) pos)
        (aref (aref (interpolated spline) 2) pos)
        (aref (aref (interpolated spline) 3) pos)
        (aref (aref (interpolated spline) 4) pos)))

(defmethod map-points ((spline spline) function &key from to)
  (unless from (setf from 0))
  (unless to (setf to (point-count spline)))
  (let ((xs (aref (interpolated spline) 0))
        (ys (aref (interpolated spline) 1))
        (xts (aref (interpolated spline) 2))
        (yts (aref (interpolated spline) 3))
        (ps (aref (interpolated spline) 4)))
    (loop for i from from below to
          do (funcall function (aref xs i) (aref ys i) (aref xts i) (aref yts i) (aref ps i)))))
